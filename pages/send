<template>
    <div class="flex justify-between space-x-8 items-start">
        <div class="islandBookUser islandColorCss" id="bookIsland">
            <h2 class="text-xl font-semibold mb-4">Books</h2>
            <div v-for="book in booksOutput" :key="book.title" class="mb-2">
                <h3 @click="goToDetails(book)" class="cursor-pointer text-lg hover:underline p-2" :class="{
                    'circular-gradient-border': recomandedBooks.has(book.title)
                }">
                    {{ book.title }}
                </h3>
            </div>
        </div>

        <div class="w-full">
            <svg class="w-full border border-gray-300" :style="{ height: svgHeight + 'px' }">
                <path v-for="(path, index) in paths" :key="index" ref="pathRefs" :d="path" stroke="blue"
                    stroke-width="3" fill="transparent" :stroke-dasharray="pathLengths[index]"
                    :stroke-dashoffset="pathLengths[index]">
                    <animate attributeName="stroke-dashoffset" :from="pathLengths[index]" to="0" dur="10s"
                        fill="freeze" />
                </path>
            </svg>
        </div>

        <div class="islandBookUser islandColorCss" id="userIsland">
            <h2 class="text-xl font-semibold mb-4">Users</h2>
            <div v-for="user in usersOutput" :key="user.name" class="mb-4">
                <h3 class="text-lg" :class="userClass[user.name]">
                    {{ user.name }} {{ user.surrname }}</h3>
                <button @click="getByReadingLvl(user)"
                    class="mt-2 px-4 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 cursor-pointer">
                    Reading Level
                </button>
                <button @click="getBookMultiple(user.preferedTheme, user.readingLvl)"
                    class="mt-2 px-4 py-1 bg-blue-500 text-white rounded-lg hover:bg-blue-600 cursor-pointer">
                    Theme and Reading Level
                </button>
            </div>
        </div>
    </div>
</template>

<script lang="ts" setup>

const animatedLines = ref<Record<string, boolean>>({});

const pathLengths = ref<number[]>([]);
const pathRefs = ref<SVGPathElement[]>([]);

const svgHeight = ref(0);


interface Point {
    x: number,
    y: number
}

const getBezierPath = (x1: number, y1: number, x2: number, y2: number) => {
    const control1 = { x: (x1 + x2) / 2 + 80, y: y1 - 100 }; // Bigger loops
    const control2 = { x: (x1 + x2) / 2 - 80, y: y2 + 100 };

    return `M${x1},${y1} C${control1.x},${control1.y} ${control2.x},${control2.y} ${x2},${y2}`;
};


const paths = computed(() => points.value.map((point: Point) =>
    getBezierPath(coordinatesUser.value.x, coordinatesUser.value.y, point.x, point.y)));


const updatePathLengths = () => {
    nextTick(() => {
        pathLengths.value = pathRefs.value.map((path) => path?.getTotalLength() || 0);
    });
};

onMounted(async () => {
    await getAllEntriesBook();
    await getAllEntriesUser();
    uppdateSvg()
    updatePathLengths()

})


const getByReadingLvl = async (user: User) => {

    points.value.length = 0;
    pathLengths.value.length = 0;
    pathLengths.value = [];
    pathRefs.value = [];


    await getBookByReadingLevel(user.readingLvl);
    selectedUser.value = user;

    await uppdateAll();
    uppdateSvgBoxSize();
    updatePathLengths();
}

const uppdateAll = async () => {

    await nextTick();

    const highlightedBooks = document.querySelectorAll<HTMLElement>(".circular-gradient-border");
    const highlightedUser = document.querySelector<HTMLElement>(".circular-gradient-border2");
    if (highlightedUser) {
        const rect = highlightedUser.getBoundingClientRect();
        coordinatesUser.value = { x: rect.x - 300, y: rect.y }
    }

    await nextTick();

    highlightedBooks.forEach((el, index) => {
        const rect = el.getBoundingClientRect();
        const point: coords = { x: rect.x - 50, y: rect.y - 50 };
        points.value.push(point);

    });
}


const recomandedBooks = computed(() => {
    return new Set(booksOutputRecomandations.value.map(b => b.title));
})



</script>